/********************************************************************************
**
** 文件名:     YX_Stream.C
** 版权所有:   (c) 2007-2008 厦门雅迅网络股份有限公司
** 文件描述:   实现数据流管理功能
**
*********************************************************************************
**             修改历史记录
**===============================================================================
**| 日期       | 作者   |  修改记录
**===============================================================================
**| 2007/04/11 | 陈从华 |  创建该文件
**| 2008/10/13 | 任赋   |  使用原车台程序实现和接口
*********************************************************************************/
#include "yx_includes.h"
//#include "yx_system.h"
#include "yx_structs.h"
#include "bal_stream.h"

/*
********************************************************************************
* 定义模块变量
********************************************************************************
*/
static INT8U s_tempbuf[1024];
static STREAM_T s_wstrm;

/*******************************************************************
** 函数名:     bal_InitStrm
** 函数描述:   初始化数据流
** 参数:       [in]  Sp:              数据流
**             [in]  Bp:              数据流所管理内存地址
**             [in]  MaxLen:          数据流所管理内存字节数
** 返回:       成功或失败
********************************************************************/
BOOLEAN bal_InitStrm(STREAM_T *Sp, STREAMMEM *Bp, INT32U MaxLen)
{
    if (Sp == 0) return FALSE;

    Sp->Len      = 0;
    Sp->MaxLen   = MaxLen;
    Sp->CurPtr   = Bp;
    Sp->StartPtr = Bp;
    return TRUE;
}

/*******************************************************************
** 函数名:     bal_GetStrmLeftLen
** 函数描述:   获取数据流中剩余的可用字节数
** 参数:       [in]  Sp:              数据流
** 返回:       数据流剩余的可用字节数
********************************************************************/
INT32U bal_GetStrmLeftLen(STREAM_T *Sp)
{
    if (Sp->MaxLen >= Sp->Len) {
        return (Sp->MaxLen - Sp->Len);
    } else {
        return 0;
    }
}

/*******************************************************************
** 函数名:     bal_GetStrmLen
** 函数描述:   获取数据流中已用字节数
** 参数:       [in]  Sp:              数据流
** 返回:       数据流已用字节数
********************************************************************/
INT32U bal_GetStrmLen(STREAM_T *Sp)
{
    return (Sp->Len);
}

/*******************************************************************
** 函数名:     bal_GetStrmMaxLen
** 函数描述:   获取数据流缓存总长度
** 参数:       [in]  Sp:              数据流
** 返回:       数据流的最大长度
********************************************************************/
INT32U bal_GetStrmMaxLen(STREAM_T *Sp)
{
    return (Sp->MaxLen);
}
/*******************************************************************
** 函数名:     bal_GetStrmPtr
** 函数描述:   获取数据流当前读/写指针
** 参数:       [in]  Sp:              数据流
** 返回:       当前读/写指针
********************************************************************/
STREAMMEM *bal_GetStrmPtr(STREAM_T *Sp)
{
    return (Sp->CurPtr);
}

/*******************************************************************
** 函数名:     bal_GetStrmStartPtr
** 函数描述:   获取数据流所管理内存的地址
** 参数:       [in]  Sp:              数据流
** 返回:       所管理内存地址
********************************************************************/
STREAMMEM *bal_GetStrmStartPtr(STREAM_T *Sp)
{
    return (Sp->StartPtr);
}

/*******************************************************************
** 函数名:     bal_MovStrmPtr
** 函数描述:   移动数据流中读/写指针
** 参数:       [in]  Sp:              数据流
**             [in]  Len:             移动字节数
** 返回:       无
********************************************************************/
void bal_MovStrmPtr(STREAM_T *Sp, INT32U Len)
{
    if (Sp != 0) {
        if ((Sp->Len + Len) <= Sp->MaxLen) {
            Sp->Len    += Len;
            Sp->CurPtr += Len;
        } else {
            Sp->Len = Sp->MaxLen;
        }
    }
}

/*******************************************************************
** 函数名:     bal_WriteBYTE_Strm
** 函数描述:   往数据流中写入一个字节数据
** 参数:       [in]  Sp:              数据流
**             [in]  writebyte:       写入的数据
** 返回:       无
********************************************************************/
void bal_WriteBYTE_Strm(STREAM_T *Sp, INT8U writebyte)
{
    if (Sp != 0){
        if (Sp->Len < Sp->MaxLen) {
            *Sp->CurPtr++ = writebyte;
            Sp->Len++;
        }
    }
}

/*******************************************************************
** 函数名:     bal_WriteHWORD_Strm
** 函数描述:   往数据流中写入一个半字(16位)数据, 大端模式(高字节先写，低字节后写)
** 参数:       [in]  Sp:              数据流
**             [in]  writeword:       写入的数据
** 返回:       无
********************************************************************/
void bal_WriteHWORD_Strm(STREAM_T *Sp, INT16U writeword)
{
    HWORD_UNION temp;

    temp.hword = writeword;
    bal_WriteBYTE_Strm(Sp, temp.bytes.high);
    bal_WriteBYTE_Strm(Sp, temp.bytes.low);
}

/*******************************************************************
** 函数名:     bal_LE_WriteHWORD_Strm
** 函数描述:   往数据流中写入一个半字(16位)数据, 小端模式(低字节先写，高字节后写)
** 参数:       [in]  Sp:              数据流
**             [in]  writeword:       写入的数据
** 返回:       无
********************************************************************/
void bal_LE_WriteHWORD_Strm(STREAM_T *Sp, INT16U writeword)
{
    HWORD_UNION temp;

    temp.hword = writeword;
    bal_WriteBYTE_Strm(Sp, temp.bytes.low);
    bal_WriteBYTE_Strm(Sp, temp.bytes.high);
}

/*******************************************************************
** 函数名:     bal_WriteLONG_Strm
** 函数描述:   往数据流中写入一个半字(32位)数据, 大端模式(高字节先写，低字节后写)
** 参数:       [in]  Sp:              数据流
**             [in]  writeword:       写入的数据
** 返回:       无
********************************************************************/
void bal_WriteLONG_Strm(STREAM_T *sp, INT32U writelong)
{
    bal_WriteHWORD_Strm(sp, writelong >> 16);
    bal_WriteHWORD_Strm(sp, writelong);
}

/*******************************************************************
** 函数名:     bal_LE_WriteLONG_Strm
** 函数描述:   往数据流中写入一个半字(32位)数据, 小端模式(低字节先写，高字节后写)
** 参数:       [in]  Sp:              数据流
**             [in]  writeword:       写入的数据
** 返回:       无
********************************************************************/
void bal_LE_WriteLONG_Strm(STREAM_T *sp, INT32U writelong)
{
    bal_LE_WriteHWORD_Strm(sp, writelong);
    bal_LE_WriteHWORD_Strm(sp, writelong >> 16);    //高16位
}

/*******************************************************************
** 函数名:     bal_WriteLF_Strm
** 函数描述:   往数据流中写入换行符, 即写入'\r'和'\n'
** 参数:       [in]  Sp:              数据流
** 返回:       无
********************************************************************/
void bal_WriteLF_Strm(STREAM_T *Sp)
{
    bal_WriteBYTE_Strm(Sp, 0x0d);
    bal_WriteBYTE_Strm(Sp, 0x0a);
}

/*******************************************************************
** 函数名:     GpsStrm_WriteLF
** 函数描述:   往数据流中写入回车符, 即写入'\r''
** 参数:       [in]  Sp:              数据流
** 返回:       无
********************************************************************/
void bal_WriteCR_Strm(STREAM_T *Sp)
{
    bal_WriteBYTE_Strm(Sp, 0x0d);
}

/*******************************************************************
** 函数名:     bal_WriteSTR_Strm
** 函数描述:   往数据流中写入字符串
** 参数:       [in]  Sp:              数据流
**             [in]  Ptr:             写入的字符串指针
** 返回:       无
********************************************************************/
void bal_WriteSTR_Strm(STREAM_T *Sp, char *Ptr)
{
    while(*Ptr)
    {
        bal_WriteBYTE_Strm(Sp, *Ptr++);
    }
}

/*******************************************************************
** 函数名:     bal_WriteDATA_Strm
** 函数描述:   往数据流中写入一块内存数据
** 参数:       [in]  Sp:              数据流
**             [in]  Ptr:             写入的数据块地址
**             [in]  Len:             写入的数据块字节数
** 返回:       无
********************************************************************/
void bal_WriteDATA_Strm(STREAM_T *Sp, INT8U *Ptr, INT32U Len)
{
    while(Len--)
    {
        bal_WriteBYTE_Strm(Sp, *Ptr++);
    }
}

/*******************************************************************
** 函数名:     bal_ReadBYTE_Strm
** 函数描述:   从数据流中读取一个字节
** 参数:       [in]  Sp:              数据流
** 返回:       读取到的字节
********************************************************************/
INT8U bal_ReadBYTE_Strm(STREAM_T *Sp)
{
    Sp->Len++;
    return (*Sp->CurPtr++);
}

/*******************************************************************
** 函数名:     bal_ReadHWORD_Strm
** 函数描述:   从数据流中读取一个半字(16位)数据,大端模式(先读为高字节，后读为低字节)
** 参数:       [in]  Sp:              数据流
** 返回:       读取到的字
********************************************************************/
INT16U bal_ReadHWORD_Strm(STREAM_T *Sp)
{
    HWORD_UNION temp;

    temp.bytes.high = bal_ReadBYTE_Strm(Sp);
    temp.bytes.low  = bal_ReadBYTE_Strm(Sp);
    return temp.hword;
}

/*******************************************************************
** 函数名:     bal_LE_ReadHWORD_Strm
** 函数描述:   从数据流中读取一个半字(16位)数据,小端模式(先读为低字节，后读为高字节)
** 参数:       [in]  Sp:              数据流
** 返回:       读取到的字
********************************************************************/
INT16U bal_LE_ReadHWORD_Strm(STREAM_T *Sp)
{
    HWORD_UNION temp;

    temp.bytes.low   = bal_ReadBYTE_Strm(Sp);
    temp.bytes.high  = bal_ReadBYTE_Strm(Sp);
    return temp.hword;
}

/*******************************************************************
** 函数名:     bal_ReadLONG_Strm
** 函数描述:   从数据流中读取一个半字(32位)数据,大端模式(先读为高字节，后读为低字节)
** 参数:       [in]  Sp:              数据流
** 返回:       读取到的字
********************************************************************/
INT32U bal_ReadLONG_Strm(STREAM_T *Sp)
{
    INT32U temp;

	temp = (bal_ReadHWORD_Strm(Sp) << 16);
	temp += bal_ReadHWORD_Strm(Sp);

    return temp;
}

/*******************************************************************
** 函数名:     bal_LE_ReadLONG_Strm
** 函数描述:   从数据流中读取一个半字(32位)数据,小端模式(先读为低字节，后读为高字节)
** 参数:       [in]  Sp:              数据流
** 返回:       读取到的字
********************************************************************/
INT32U bal_LE_ReadLONG_Strm(STREAM_T *Sp)
{
    INT32U temp;

	temp = bal_LE_ReadHWORD_Strm(Sp);
	temp += (bal_LE_ReadHWORD_Strm(Sp) << 16);

    return temp;
}

/*******************************************************************
** 函数名:     bal_ReadDATA_Strm
** 函数描述:   从数据流中读取指定长度的数据内容
** 参数:       [in]  Sp:              数据流
**             [out] Ptr:             读取到的数据存放的内存地址
**             [in]  Len:             读取的数据长度
** 返回:       无
********************************************************************/
void bal_ReadDATA_Strm(STREAM_T *Sp, INT8U *Ptr, INT32U Len)
{
    while(Len--)
    {
        *Ptr++ = bal_ReadBYTE_Strm(Sp);
    }
}

/*******************************************************************
** 函数名:     bal_STREAM_GetBufferStream
** 函数描述:   获取流缓存，目前流缓存最大为2000字节
**             备注：本接口用于需要暂时需要缓存地方，如各类外设组帧发送，注意不要冲突使用
** 参数:       无
** 返回:       放回流指针
********************************************************************/
STREAM_T *bal_STREAM_GetBufferStream(void)
{
    bal_InitStrm(&s_wstrm, s_tempbuf, sizeof(s_tempbuf));
    return &s_wstrm;
}
